import re
import string
from typing import Any, List, Optional

import torch
from torch import Tensor
from torchmetrics import Metric


class ExactMatch(Metric):
    """Exact Match metric for comparing predicted strings with reference strings.
    
    This metric computes the rate at which predicted strings exactly match their
    references. It supports optional text normalization through regex filtering,
    case normalization, punctuation removal, and number removal.
    
    Args:
        regexes_to_ignore: List of regex patterns to remove from strings before comparison.
            Default: None
        ignore_case: If True, converts all text to lowercase before comparison.
            Default: False
        ignore_punctuation: If True, removes all punctuation before comparison.
            Default: False
        ignore_numbers: If True, removes all digits before comparison.
            Default: False
        **kwargs: Additional keyword arguments passed to the parent Metric class.
    
    Example:
        >>> from torchmetrics import ExactMatch
        >>> metric = ExactMatch()
        >>> preds = ["the cat", "theater"]
        >>> target = ["the cat", "theatre"]
        >>> metric(preds, target)
        tensor(0.5000)
    """
    
    is_differentiable: bool = False
    higher_is_better: bool = True
    full_state_update: bool = False
    
    def __init__(
        self,
        regexes_to_ignore: Optional[List[str]] = None,
        ignore_case: bool = False,
        ignore_punctuation: bool = False,
        ignore_numbers: bool = False,
        **kwargs: Any,
    ):
        super().__init__(**kwargs)
        
        self.regexes_to_ignore = regexes_to_ignore or []
        self.ignore_case = ignore_case
        self.ignore_punctuation = ignore_punctuation
        self.ignore_numbers = ignore_numbers
        
        # Add metric states
        self.add_state("correct", default=torch.tensor(0), dist_reduce_fx="sum")
        self.add_state("total", default=torch.tensor(0), dist_reduce_fx="sum")
    
    def _normalize_text(self, text: str) -> str:
        """Apply text normalization based on metric configuration.
        
        Args:
            text: Input string to normalize
            
        Returns:
            Normalized string
        """
        # Apply regex removals first (before case normalization)
        for regex in self.regexes_to_ignore:
            text = re.sub(regex, "", text)
        
        # Normalize case
        if self.ignore_case:
            text = text.lower()
        
        # Remove punctuation
        if self.ignore_punctuation:
            text = text.translate(str.maketrans("", "", string.punctuation))
        
        # Remove numbers
        if self.ignore_numbers:
            text = re.sub(r"\d", "", text)
        
        return text
    
    def update(self, preds: List[str], target: List[str]) -> None:
        """Update metric state with new predictions and targets.
        
        Args:
            preds: List of predicted strings
            target: List of reference strings
            
        Raises:
            ValueError: If preds and target have different lengths
        """
        if len(preds) != len(target):
            raise ValueError(
                f"Number of predictions ({len(preds)}) must match "
                f"number of targets ({len(target)})"
            )
        
        # Normalize and compare strings
        for pred, ref in zip(preds, target):
            pred_normalized = self._normalize_text(pred)
            ref_normalized = self._normalize_text(ref)
            
            if pred_normalized == ref_normalized:
                self.correct += 1
            self.total += 1
    
    def compute(self) -> Tensor:
        """Compute the exact match score.
        
        Returns:
            Exact match score as a float tensor in range [0, 1]
        """
        if self.total == 0:
            return torch.tensor(0.0)
        return self.correct.float() / self.total
